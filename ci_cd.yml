# name: Full CI/CD - Backend & Frontend

# on:
#   push:
#     branches: [main]             
#   pull_request:
#     branches: [development]       
#   workflow_dispatch:              

# env:
#   ACR_LOGIN_SERVER: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
#   IMAGE_TAG: ${{ github.sha }}-${{ github.run_id }}

# jobs:
#   build_and_deploy:
#     runs-on: ubuntu-latest
#     environment: Production

#     services:
#       product_db:
#         image: postgres:15
#         env:
#           POSTGRES_USER: postgres
#           POSTGRES_PASSWORD: postgres
#           POSTGRES_DB: products
#         options: >-
#           --health-cmd "pg_isready -U postgres"
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5432:5432

#       order_db:
#         image: postgres:15
#         env:
#           POSTGRES_USER: postgres
#           POSTGRES_PASSWORD: postgres
#           POSTGRES_DB: orders
#         options: >-
#           --health-cmd "pg_isready -U postgres"
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5433:5432

#     steps:
#       # 1. Checkout repo
#       - name: Checkout repository
#         uses: actions/checkout@v4

#       # 2. Login to Azure
#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}

#       # 3. Backend CI: Install deps & Run Tests ...
#       - name: Set up Python 3.10
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.10'

#       - name: Install backend dependencies
#         run: |
#           pip install --upgrade pip
#           for req in backend/*/requirements.txt; do
#             echo "Installing $req"
#             pip install -r "$req"
#           done
#           pip install pytest httpx

#       - name: Run product_service tests
#         working-directory: backend/product_service
#         env:
#           POSTGRES_HOST: localhost
#           POSTGRES_PORT: 5432
#           POSTGRES_DB: products
#           POSTGRES_USER: postgres
#           POSTGRES_PASSWORD: postgres
#         run: pytest tests --maxfail=1 --disable-warnings -q

#       - name: Run order_service tests
#         working-directory: backend/order_service
#         env:
#           POSTGRES_HOST: localhost
#           POSTGRES_PORT: 5433
#           POSTGRES_DB: orders
#           POSTGRES_USER: postgres
#           POSTGRES_PASSWORD: postgres
#         run: pytest tests --maxfail=1 --disable-warnings -q

#       # 4. Backend CI: Build & Push Images
#       - name: Login to Azure Container Registry
#         run: az acr login --name ${{ env.ACR_LOGIN_SERVER }}

#       - name: Build & Push Product Service Image
#         run: |
#           docker build -t ${{ env.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }} ./backend/product_service
#           docker push ${{ env.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }}

#       - name: Build & Push Order Service Image
#         run: |
#           docker build -t ${{ env.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }} ./backend/order_service
#           docker push ${{ env.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }}


#       # 5. Backend CD: Deploy Backend Services
#       - name: Get AKS Credentials
#         run: az aks get-credentials --resource-group ${{ secrets.AKS_RG }} --name ${{ secrets.AKS_CLUSTER }} --overwrite-existing

#       - name: Attach ACR to AKS
#         run: az aks update --name ${{ secrets.AKS_CLUSTER }} --resource-group ${{ secrets.AKS_RG }} --attach-acr ${{ secrets.ACR_NAME }}

#       - name: Deploy Backend Infrastructure
#         run: |
#           kubectl apply -f k8s/configmaps.yaml
#           kubectl apply -f k8s/secrets.yaml
#           kubectl apply -f k8s/product-db.yaml
#           kubectl apply -f k8s/order-db.yaml

#       - name: Deploy Backend Microservices
#         run: |
#           kubectl apply -f k8s/product-service.yaml
#           kubectl apply -f k8s/order-service.yaml

#       # 6. Capture Backend IPs
#       - name: Wait for Backend LoadBalancer IPs
#         id: capture_backend_ips
#         run: |
#           echo "Waiting for Product and Order service IPs..."
#           for i in {1..60}; do
#             PRODUCT_IP=$(kubectl get svc product-service-w08e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
#             ORDER_IP=$(kubectl get svc order-service-w08e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
#             if [[ -n "$PRODUCT_IP" && -n "$ORDER_IP" ]]; then
#               echo "Product Service IP: $PRODUCT_IP"
#               echo "Order Service IP: $ORDER_IP"
#               echo "PRODUCT_IP=$PRODUCT_IP" >> $GITHUB_ENV
#               echo "ORDER_IP=$ORDER_IP" >> $GITHUB_ENV
#               break
#             fi
#             sleep 5
#           done
#           if [[ -z "$PRODUCT_IP" || -z "$ORDER_IP" ]]; then
#             echo "Error: IPs not assigned"
#             exit 1
#           fi

#       # 7. Inject Backend IPs into Frontend
#       - name: Inject Backend IPs into Frontend main.js
#         run: |
#           sed -i "s|_PRODUCT_API_URL_|${{ env.PRODUCT_IP }}|g" frontend/main.js
#           sed -i "s|_ORDER_API_URL_|${{ env.ORDER_IP }}|g" frontend/main.js
#           echo "--- Modified main.js ---"
#           cat frontend/main.js

#       # 8. Frontend CI: Build & Push Images & Deploy
#       - name: Build & Push Frontend Image
#         run: |
#           docker build -t ${{ env.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} ./frontend
#           docker push ${{ env.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

#       # 9. Frontend CD: Deploy Frontend
#       - name: Deploy Frontend to AKS
#         run: kubectl apply -f k8s/frontend.yaml

#       # 10. Logout from Azure
#       - name: Logout from Azure
#         run: az logout
#         if: always()
